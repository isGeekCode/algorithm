////
////  BJ_2559.swift
////  Algorithm
////
////  Created by 방현석 on 6/4/24.
////
//
//import Foundation
//
//// MARK: 수열
//
//
///**
// 
// - 문제
// 매일 아침 9시에 학교에서 측정한 온도가 어떤 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 알아보고자 한다.
//
// 예를 들어, 아래와 같이 10일 간의 온도가 주어졌을 때,
//
// 3 -2 -4 -9 0 3 7 13 8 -3
//
// 모든 연속적인 이틀간의 온도의 합은 아래와 같다.
//
// 이때, 온도의 합이 가장 큰 값은 21이다.
//
// 또 다른 예로 위와 같은 온도가 주어졌을 때, 모든 연속적인 5일 간의 온도의 합은 아래와 같으며,
//
// 이때, 온도의 합이 가장 큰 값은 31이다.
//
// 매일 측정한 온도가 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 계산하는 프로그램을 작성하시오.
//
//
// 
// - 입력
// 첫째 줄에는 두 개의 정수 N과 K가 한 개의 공백을 사이에 두고 순서대로 주어진다. 첫 번째 정수 N은 온도를 측정한 전체 날짜의 수이다. N은 2 이상 100,000 이하이다. 두 번째 정수 K는 합을 구하기 위한 연속적인 날짜의 수이다. K는 1과 N 사이의 정수이다. 둘째 줄에는 매일 측정한 온도를 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -100 이상 100 이하이다.
//
//
// 
// - 출력
// 첫째 줄에는 입력되는 온도의 수열에서 연속적인 K일의 온도의 합이 최대가 되는 값을 출력한다.
//
//
// 
// - 예제1
// - 예제 입력 :
// 10 2
// 3 -2 -4 -9 0 3 7 13 8 -3
// - 예제 출력 :
// 21
// 
// - 예제2
// - 예제 입력 :
// 10 5
// 3 -2 -4 -9 0 3 7 13 8 -3
// - 예제 출력 :
// 31
// 
// */
//
//// MARK: 내 답
//
//
///// 1. 아이디어
///// - 투 포인터를 활용
///// - for문으로  처음에 K값을 저장한다.
///// - 다음 인덱스를 더해주고, 이전 인덱스는  빼준다.
///// - 이때마다 최대값을 갱신한다.
/////
///// 2. 시간 복잡도
///// - O(N)  = 1e5 (십만) -> 가능
/////
///// 3. 자료구조
///// - 각 숫자들을 N개 저장하는 배열 [Int]
/////     - 각 숫자의 범위는 100까지임 -> Int 가능
///// - K개의 숫자를 더할 최대값 저장 변수 : Int
/////     - 최대 ::: K * 100 :::: 1e5 * 100 = 1e7 -> Int 가능
///// - 최대값 Int
//
//
//
//let input = readLine()!.split(separator: " ").map{ Int($0)! }
//let (n, k) = (input[0], input[1])
//let nums = readLine()!.split(separator: " ").map{ Int($0)! }
//
////let input2 = """
////            10 5
////            3 -2 -4 -9 0 3 7 13 8 -3
////            """
////let input3 = """
////10 2
////3 -2 -4 -9 0 3 7 13 8 -3
////"""
////
//
////print(input2)
////let fullArr = input3.split(separator: "\n")
////let numArr  = fullArr[0].split(separator: " ").map({Int($0)!})
////let (n, k) = (numArr[0], numArr[1])
////let nums = fullArr[1].split(separator: " ").map({Int($0)!})
//
//var each = 0
//var maxv = 0
//// K개를 더해주기
//for i in 0..<k {
//    each += nums[i]
//}
//maxv = each
//// 다음 인덱스를 더해주고, 이전 인덱스를 빼주기
//
//for i in k..<n {
//    each += nums[i]
//    each -= nums[i-k]
//    maxv = max(maxv, each)
//}
//print(maxv)
//
//
//// MARK: Insight
///*
// <#text#>
// */
//
//
//// MARK: Other Idea
///*
// <#text#>
// */
//
//
//// MARK: 다른 답 중 인상적인 답
